# Long-running operations

Occasionally, an service may need to expose an endpoint that takes a
significant amount of time to complete. In these situations, it is often a poor
user experience to simply block while the task runs; rather, it is better to
return some kind of promise to the user and allow the user to check back in
later.

The long-running operations pattern is roughly analogous to a [Future][] in
Python or Java, or a [Node.js Promise][]. Essentially, the user is given a
token that can be used to track progress and retrieve the result.

## Guidance

Endpoints that might take a significant amount of time to complete **should**
return a `202 Accepted` response along with an identifier that can be used to
track the status of the operation and ultimately retrieve the result.

Any single endpoint defined in an API surface **must** either _always_ return
`202 Accepted` along with an operation identifier, or _never_ do so. A service
**must not** return a `200 OK` response with the result if it is "fast enough",
and `202 Accepted` if it is not fast enough, because such behavior adds
significant burdens for clients.

**Note:** User expectations can vary on what is considered "a significant
amount of time" depending on what work is being done. A good rule of thumb is
10 seconds.

### Operation representation

Operations **should** use a common format:

```typescript
interface Operation {
  // The identifier for this operation.
  name: string;

  // Whether the operation is done.
  done: boolean;

  // The result of the operation.
  // Only populated if the operation is done and was successful.
  response: any;

  // The error that arose from the operation.
  // Only populated if the operation is done and was unsuccessful.
  error: Error;

  // Metadata associated with the operation.
  // Populated throughout the life of the operation, including after
  // it completes.
  metadata: any;
}
```

- If the `done` field is `true`, then one and exactly one of the `response` and
  `error` fields **must** be populated.
  - If the `done` field is `false`, then the `response` and `error` fields
    **must not** be populated.
- The `response` and `metadata` fields **may** be any type that the service
  determines to be appropriate, but **must** always be the same type for any
  particular operation.
  - The `response` and `metadata` types **should** be defined in the same API
    surface as the operation itself.
  - The `response` and `metadata` types that need no data **should** use a
    custom-defined empty struct rather than a common void or empty type, to
    permit future extensibility.

### Querying an operation

The service **must** provide an endpoint to query the status of the operation,
which **must** accept the operation identifier and **should not** include other
parameters:

```http
GET /v1/operations/{operation} HTTP/2
Host: library.googleapis.com
Accept: application/json
```

The endpoint **must** return an `Operation` as described above.

### Standard methods

APIs **may** return an `Operation` from the [`Create`][aip-133],
[`Update`][aip-134], or [`Delete`][aip-135] standard methods if appropriate. In
this case, the `response` field **must** be the standard and expected response
type for that standard method.

When creating or deleting a resource with a long-running operation, the
resource **should** be included in [`List`][aip-132] and [`Get`][aip-131]
calls; however, the resource **should** indicate that it is not usable,
generally with a [state enum][aip-216].

### Parallel operations

A resource **may** accept multiple operations that will work on it in parallel,
but is not obligated to do so:

- Resources that accept multiple parallel operations **may** place them in a
  queue rather than work on the operations simultaneously.
- Resource that does not permit multiple operations in parallel (denying any
  new operation until the one that is in progress finishes) **must** return
  `ABORTED` if a user attempts a parallel operation, and include an error
  message explaining the situation.

### Expiration

APIs **may** allow their operation resources to expire after sufficient time
has elapsed after the operation completed.

**Note:** A good rule of thumb for operation expiry is 30 days.

### Errors

Errors that prevent a long-running operation from _starting_ **must** return an
error response (AIP-193), similar to any other method.

Errors that occur over the course of an operation **may** be placed in the
metadata message. The errors themselves **must** still be represented with a
canonical error object.

## Interface Definitions

{% tab proto %}

When using protocol buffers, the well-known type `google.longrunning.Operation`
is used:

{% sample 'lro.proto', 'rpc WriteBook' %}

- The response type **must** be `google.longrunning.Operation`. The `Operation`
  proto definition **must not** be copied into individual APIs.
  - The response **must not** be a streaming response.
- The method **must** include a `google.longrunning.operation_info` annotation,
  which **must** define both response and metadata types.
  - The response and metadata types **must** be defined in the file where the
    RPC appears, or a file imported by that file.
  - If the response and metadata types are defined in another package, the
    fully-qualified message name **must** be used.
  - The response type **should not** be `google.protobuf.Empty` (except for
    [`Delete`][aip-135] methods), unless it is certain that response data will
    _never_ be needed. If response data might be added in the future, define an
    empty message for the RPC response and use that.
  - The metadata type is used to provide information such as progress, partial
    failures, and similar information on each `GetOperation` call. The metadata
    type **should not** be `google.protobuf.Empty`, unless it is certain that
    metadata will _never_ be needed. If metadata might be added in the future,
    define an empty message for the RPC metadata and use that.
- APIs with messages that return `Operation` **must** implement the
  [`Operations`][lro] service. Individual APIs **must not** define their own
  interfaces for long-running operations to avoid inconsistency. {% endtabs %}

{% tab oas %}

{% endtabs %}

<!-- prettier-ignore-start -->
[google.rpc.Status]: https://github.com/googleapis/api-common-protos/blob/master/google/rpc/S.proto
[lro]: https://github.com/googleapis/api-common-protos/blob/master/google/longrunning/operations.proto
[node.js promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises
[future]: https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future
<!-- prettier-ignore-end -->
